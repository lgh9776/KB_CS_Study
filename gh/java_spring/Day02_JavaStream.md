8. Java Stream에 대해 설명해 주세요.
> 면접&공부
람다를 사용해서 배열과 컬렉션을 쉽게 사용할 수 있는
메서드  .map .filter

스트림은 컬렉션, 배열 등의 요소를 1개씩 처리하는 기능 제공
저장소가 아니고 데이터 처리의 연속적인 흐름
데이터 소스를 변경하지 않고 처리

코드의 재사용성, 가독성이 좋아짐

-------------------

- Stream과 for ~ loop의 성능 차이를 비교해 주세요.
> 면접&공부
1) 작은 데이터 세트 (단순 반복)
스트림 사용 시 iterator를 사용해서 약간의 오버헤드 발생 가능
-> for 루프

2) 큰 데이터 세트
스트림에서 parallelStream()으로 쉬운 병렬처리 지원
-> 병렬 처리로 성능 향상 가능 //for 루프는 무조건 직렬 처리하기 때문

Q1) iterator를 사용 시 오버헤드가 발생하는 이유
메서드 호출 : asNext(), next()와 같은 메서드를 호출하여 요소를 순회
iterator 객체 생성 오버헤드

-------------------

- Stream은 병렬처리 할 수 있나요?
> 면접&공부
parallelStream() : 직접 병렬 스트림 생성
stream().parallel() : 기존 스트림을 병렬 스트림으로 전환

-------------------

- Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
> 면접&공부
함수형 인터페이스는 1개의 추상 메서드만 가지며, 이를 람다 표현식이나 메서드 참조로 사용할 수 있음
ex) Predicate<T> : 입력값을 받아서 boolean 반환 (filter 사용)
Function<T, R> : 다른 타입의 값을 반환 (map에 사용) //입력값의 타입 T -> R
Consumer<T> : 입력값을 받아서 소비함. 값 반환x (foreach에 사용) //Consumer<String> print = System.out::println;

-------------------

- 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
> 면접&공부
스트림 -> 람다 표현식, 익명 클래스 규칙 따름
(자바 컴파일러가 람다 표현식에서 외부 변수를 사용할 때 변수의 변경되지 않음을 보장하기 위해서 제약)

1) 다른 스레드에서 실행될 경우 외부 변수의 변경이 스레드 간 일관성 유지를 어렵게 만들기 때문 -> final로 초기화 이후 변경되지 않음을 보장하여 스레드 안전성 확보

2) 외부 변수 사용 시 값이 캡쳐되는 방식 -> 자바 컴파일러는 람다식/익명 클래스이 사용되는 시점의 변수값을 저장하고 사용 -> 변수 변경이 가능하면 어떤 시점을 값을 사용할지 명확하지 않게 됨

3) 외부 변수를 참조하는 방식을 제한 -> 일관성 유지

꼭 그래야 합니다! 자바 컴파일러가 요구하는 규칙이고, 이를 통해 코드의 안전성과 일관성 보장 가능
(배열이나 Wrapper 클래스 사용 시 변경은 가능함...)

동기화에 대한 문제.
병렬 스트림을 사용할 때 절대 변경되지 않아야할 데이터가 있을 수 있음
그럴 때 final 키워드를 사용하자!
그럼 그 데이터가 무엇?

어떤 곳에서 외부 변수를 참조할 때 보장해야함. final 사용해서. 그게 뭐야?
-> 람다